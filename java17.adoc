= Java 17, le record & pattern matching c’est pour maintenant ?
Antoine Salesse - a.salesse@younup.fr
:toc:

== Intro

Promis juré, cet article n’est pas une liste de https://docs.oracle.com/javase/specs/jls/se17/html/index.html[JLS]footnote:[JLS : Java Language Specification] / https://stackoverflow.com/a/51286665[JSR]footnote:[JSR : Java Specification Request] / https://stackoverflow.com/a/51286665[JEP]footnote:[JEP : JDK Enhancement Proposal].

Depuis sa sortie en septembre 2021, les articles sur Java 17 pleuvent.

Ça y est, on a bien compris que cette version est une https://stackoverflow.com/a/51286665[LTS]footnote:[LTS : Long Term Support].

Mais c’est aussi bien plus que cela.
C’est une milestone de l’objectif ambitieux nommé +
*"Record and Array Pattern Matching"*.

Cet objectif est un ensemble de fonctionnalités synergiques :

* Les `instanceof` avec "Type Patterns" (dispo en 16)
* Les Switch on Patterns (dispo en 17 preview)
* La déconstruction d’array (Peut-être dispo en 19 preview)
* La déconstruction de `record` (Peut-être dispo en 19 preview)
* Les imbrications de patterns (pas de visibilité de dispo)

C’est donc de ces features dont on parle ici :

* À quoi elles servent ?
* Que vont-elles apporter à notre code ?

Et avec bien sûr des exemples de code !

== Les applications de gestion aujourd’hui

Aujourd’hui le design de nos back-end d’applications de gestions pousse autour d’une problématique : +
*Faire varier des comportements en fonction de cas d’usage*

Dans une application modulaire idéale, un module représente un contexte métier (https://martinfowler.com/bliki/BoundedContext.html[Bounded Context]).

Illustrons cela avec 3 contextes :

* Customer
* Administrator
* Partner

Tous les 3 manipulent le concept de `Document`. +
On retrouve alors au moins 2 designs de partage de ce concept :

1.{nbsp}L’architecture hexagonale modulaire::
Elle peut prendre la forme d’un monolith modulaire, ou bien de microservices. +
Chacun des modules/services possède un package `domain` où on modélise le domaine métier, dont `Document`. +
Ils utilisent des mappers pour s’échanger le concept de `Document` à travers de https://en.wikipedia.org/wiki/Data_transfer_object[DTO]s, envoyés en http (microservices) ou en runtime (monolith modulaire). +
Grace au découplage des contextes métiers, les méthodes des classes `Document` ne peuvent pas être appelées depuis les autres modules. +
On peut alors se permettre de laisser `Document` responsable de la logique métier le concernant.
// mettre un schéma ici

2.{nbsp}L’architecture monolithique::
Ici les contextes métiers n’ont pas été découverts et il n’y a alors pas de frontière découplante entre eux. +
C’est acceptable pour une application raisonnablement complexe, dans laquelle il n’y a d'ailleurs peut-être même qu’un seul context métier. +
//Un monolith modulaire sans découplage entre les modules n'est alors pas modulaire par essence.
On a toujours une classe `Document` dans un package `domain`.

Dans le premier design, tout va bien, continuons à continuer ainsi ...

Mais dans le deuxième, attention !

Si on met dans `Document` la logique métier agissant dessus, alors on couple fortement la totalité de l'application avec l'implémentation de `Document` !
Cela impacte fortement la parallélisation, le scope (et donc la vitesse) de recompilation de l'application.

On veut alors *séparer la logique métier des entités sur lesquelles elle agit*.

Pour y parvenir, on utilisait jusque-là 2 pattern :

* le https://en.wikipedia.org/wiki/Visitor_pattern#Sources_3[visitor pattern]footnote:["Today, to express ad-hoc polymorphic calculations like this we would use the cumbersome visitor pattern". source : https://openjdk.java.net/jeps/405]
* le everything-is-a-service avec des méthodes à 8 arguments (un anti-pattern d'après moi)

Mais à présent avec java 17, une troisième solution élégante s'offre à nous : Le Pattern Matching.

== Qu’est-ce que le pattern matching ?

Je pense qu’on ne peut pas couper à la définition de Wikipédia :

[quote,https://en.wikipedia.org/wiki/Pattern_matching]
--
In computer science, pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern.
--

On a tendance à penser alors aux expressions régulières, mais non, il ne s’agit pas de cela.

Là, les patterns à matcher sont des structures de données :

* Des classes
* Des interfaces
* Des array
* Et bien sûr des records !

Je trouve que le cas du matching sur `instanceof` avec Type-Pattern est le plus facile à comprendre :

[source,java]
----
if (vehicle instanceof Car car) {
  car.drive();
} else if (vehicle instanceof Plane plane) {
  plane.fly();
}
----

Ici le pattern à matcher est l’appartenance aux classes `Car` et `Plane`.
On teste si l’instance a un des types, et une conversion implicite est faite vers une "binding variable" (`car` ou `plane`).

== Comment le Pattern Matching remplace-t-il le visitor pattern ?

//Des exemples furent promis, des exemples sont alors donnés.
Exemples j'ai promis, exemples je donne.



== Qu’est-ce que la "déconstruction"

Ce concept a un objectif similaire au I de SOLID : la ségrégation.

Si je reçois un objet avec 42 champs alors que j’en ai besoin que de 2, la "_deconstruction on pattern_" va m’aider.

Regardons ça avec du code.

J’ai mon énorme dto reçu :

[source,java]
----
public record Product(
  String type,
  String price,
  String name,
  // imaginez ici 39 autres champs
){}
----

Mais la règle métier que je veux appliquer ne porte que sur le `type` et le `price`.
Je peux alors étendre le concept de instanceof précédent, en lui ajoutant une déconstruction du Record "Product" :

[source,java]
----
if (object instanceof Product(String type, String price)) {
  myUseCase.execute(type, price);
}
----

Ici, `type` et `price` sont des "binding variables" générées implicitement si l’`object` match le pattern `Product`.

=== Et ça sert à quoi ?

Tout seul comme ça, pas encore grand-chose.

//Cela répond à un besoin fondamental des développeurs : faire varier des comportements à la Runtime. Pour un type on veut le comportement A, et pour un autre on veut le comportement B.

Pour le cas du `instanceof`, on gagne toutefois nettement en intelligibilité du code.

Comparez plutôt avec la méthode habituelle :

[source,java]
----
if (vehicle instanceof Car) {
  ((Car) vehicle).drive();
} else if (vehicle instanceof Plane) {
  ((Plane) vehicle).fly();
}
----

[source,java]
----
if (object instanceof Product) {
  String type = ((Product) object).type;
  String price = ((Product) object).price;
  myUseCase.execute(type, price);
}
----

Mais là où ça prend tout son intérêt, c’est quand on y ajoute le concept de classe scellée dans un "Switch on Pattern".

Voyons cela.

[source,java]
----
public sealed interface Document permits Invoice, Contract {}
public record Invoice(int amount, String buyer, String Seller) implements Document {}
public record Contract(List<String> parties, List<String> formalities, List<String> terms) implements Document {}
----

Ici, grâce au mécanisme de sceau (`sealed`), on indique au compilateur la liste exhaustive des implémentations de Document :

* Invoice
* Contract

Les DTO `Invoice` et `Contract` sont reçu dans les modules Customer, Administrator et Partner (1 module = 1 context métier).

Pour chaque implémentation, on veut effectuer des validations métiers différentes.

La méthode habituelle de la programmation orientée object, c’est d’avoir une méthode `void validate()` dans l’interface Document, et de la faire implémenter par Invoice et Contract.

Le problème avec ça, c’est que

Mettons alors qu’on reçoive un DTO Document.

Implémentons la sélection de la validation à appliquer à l’aide

[source,java]
----

----

Implémentons la sélection de la validation à appliquer à l’aide d’un "Switch " on Pattern :

[source,java]
----

----

== Qu’est-ce que ça va apporter à notre code ?

Plus de validation à la compile-time, et donc :

* Plus de sécurité
* Développer plus intuitivement (le compilateur nous dis ce qu’on a oublié)
* Faire émerger de meilleurs designs

=== Dans quels langages on en trouve déjà

* https://docs.scala-lang.org/tour/pattern-matching.html[Scala]
* https://doc.rust-lang.org/rust-by-example/flow_control/match.html[Rust]

== Conclusion

== brainstorm area

* Pattern guards, Guarded Pattern
* Sealed classes
* Expressivité
* le pattern matching permet de séparer la logique métier des entités sur lesquelles elle agit (Tout comme le pattern Visitor).