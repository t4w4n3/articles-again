= Java 17, le record & pattern matching c‚Äôest pour maintenant ?
Antoine Salesse - a.salesse@younup.fr
:toc:
:caution-caption: ‚ö†

== Intro

Promis jur√©, cet article n‚Äôest pas une liste des "nouvelles fonctionnalit√©s de Java" (https://docs.oracle.com/javase/specs/jls/se17/html/index.html[JLS]footnote:[JLS : Java Language Specification] /
https://stackoverflow.com/a/51286665[JSR]footnote:[JSR : Java Specification Request] / https://stackoverflow.com/a/51286665[JEP]footnote:[JEP : JDK Enhancement Proposal]).

Depuis sa sortie en septembre 2021, les articles sur Java *17* pleuvent.

Ok, √ßa y est, on a bien compris que cette version est une https://stackoverflow.com/a/51286665[LTS]footnote:[LTS : Long Term Support].

Mais c‚Äôest aussi bien plus que cela. +
C‚Äôest une milestone de l‚Äôobjectif ambitieux nomm√© +
*"Record and Array Pattern Matching"*.

Cet objectif est un ensemble de fonctionnalit√©s synergiques :

* Les `instanceof` avec "Type Patterns" (dispo en 16)
* Les Switch on Patterns (Java 17 preview, et probablement dispo en 19)
* La d√©construction de `record` (Peut-√™tre Java 19 preview)
* La d√©construction d‚Äôarray (Java 19+ ?)
* Les imbrications de patterns (pas de visibilit√© de dispo)

C‚Äôest donc de ces features dont on parle ici :

* √Ä quoi elles servent ?
* Comment et dans quels contextes les utiliser ?
* Qu‚Äôapportent-elles √† notre code ?

Et avec bien s√ªr des exemples de code !

== Les applications de gestion aujourd‚Äôhui

Aujourd‚Äôhui le design de nos backend d‚Äôapplications de gestions pousse (üå±) autour d‚Äôune probl√©matique : +
*Faire varier des comportements en fonction de cas d‚Äôusage*

Dans ce genre d'applications, quelle que soit l'architecture choisie ou le style dev, on se retrouve √† un moment ou un autre √† :

1.{nbsp}Mod√©liser notre domaine m√©tier ::
Cela peut √™tre fait dans un package sp√©cifique avec des POJO, ou avec des `Entity` JPA. +
La seconde option est la plus r√©pandue, mais ce n'est pas ma pr√©f√©r√©e.
Je trouve que c'est une erreur de concevoir le business d'une application autour d'une base de donn√©es. +
2.{nbsp}√âcrire des DTO ::
Dans l'id√©al, un dto est immutable (Il n'y a aucune raison de changer la repr√©sentation d'une donn√©e transmise √† un moment T). +
Le Record est la structure de donn√©es la plus appropri√©e. +
Sinon, avant Java 14, on a les `@Value` de Lombok.

Dans nos applications modulaires, on peut avoir envie de partager ces structures de donn√©es entre les modules :

[plantuml,a,png]
----
@startuml
allow_mixing

node "Domain model" {
	class Facture
}

node "Module lettrage" {
	usecase usecaseLettragePartiel
	usecaseLettragePartiel - Facture
}

node "Module recouvrement" {
	usecase usecasePremiereRelance
	usecasePremiereRelance - Facture
}

@enduml
----

Et bien pour faire varier les comportements des actions affectant ces classes, la POO nous incite √† ajouter des m√©thodes sur nos classes de domaine. +
//En effet, c'est un Objet, il a un √©tat, et il peut porter des m√©thodes consommant ou modifiant cet √©tat.

Par exemple, pour la domain-class `Facture`, le module lettrage pourrait vouloir ajouter une m√©thode `calculerMontantRestantAPayer()`. +
Le module envoie pourrait vouloir une m√©thode `getDestinataires()`.

[plantuml,Mod√®le de domaine avec Facture et cas d'utilisation,png]
----
@startuml
allow_mixing

node "Domain model" {


	class Facture implements MontantCalculable, Envoyable {
	Integer calculerMontantRestantAPayer()
	List<Personne> getDestinataires()
  }

  interface MontantCalculable
  interface Envoyable
}

node "Module lettrage" {
  usecase usecaseLettrage1
  usecaseLettrage1 - Facture
}

node "Module envoi" {
  usecase usecaseEnvoi1
  usecaseEnvoi1 - Facture
}

@enduml
----

[source,java]
----
class Facture implements MontantCalculable, Envoyable {
	private String libelle;
	private CodeFacture code;
	private Client client;
	private Re√ßu re√ßu;
	private Devise montant;

	@Override
	public Integer calculerMontantRestantAPayer(){
		...
	}

	@Override
	public List<Personne> getDestinataires(){
		...
	}

	...
}
----

Au bout d'un moment, notre domain-class `Facture` a beaucoup de m√©thodes issues de diff√©rents modules. +
Le module lettrage utilise `Facture` et se retrouve √† pouvoir appeler les m√©thodes du module d'envoi‚ÄØ; ce qui viole au moins :

* Le https://fr.wikipedia.org/wiki/Principe_de_s%C3%A9gr%C3%A9gation_des_interfaces[principe de s√©gr√©gation des interfaces]`
* Le https://fr.wikipedia.org/wiki/Principe_de_responsabilit%C3%A9_unique  [principe de responsabilit√© unique] (Car La class Document a maintenant 2 raisons de changer : le contexte _lettrage_ et le contexte _envoi_)

Effet bonus : Quand on change `Facture` dans le cadre du contexte _lettrage_, on doit recompiler/relivrer aussi le contexte _envoi_.

On veut alors *s√©parer la logique m√©tier des structures sur lesquelles elle agit*.

Pour y parvenir, on utilisait jusque-l√† 3 patterns :

* Le https://en.wikipedia.org/wiki/Visitor_pattern#Sources_3[visitor pattern]footnote:["Today, to express ad-hoc polymorphic calculations like this we would use the cumbersome visitor pattern". source : https://openjdk.java.net/jeps/405]
* Le https://en.wikipedia.org/wiki/Delegation_pattern[delegate pattern]
* Le pattern service-everywhere avec des m√©thodes √† 8 arguments (un anti-pattern d‚Äôapr√®s moi), qui nait de la programmation proc√©durale

Mais √† pr√©sent avec Java 17, une quatri√®me solution √©l√©gante s‚Äôoffre √† nous : Le Pattern Matching.

== Qu‚Äôest-ce que le pattern matching ?

Je pense qu‚Äôon ne peut pas couper √† la d√©finition de Wikip√©dia :

[quote,https://en.wikipedia.org/wiki/Pattern_matching]
--
In computer science, pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern.
--

On a tendance √† penser alors aux expressions r√©guli√®res, mais non, il ne s‚Äôagit pas de cela.

L√†, les patterns √† matcher sont des structures de donn√©es :

* Des classes
* Des interfaces
* Des array
* Et bien s√ªr des records !

Je trouve que le cas du matching sur `instanceof` avec Type-Pattern est le plus facile √† comprendre. +
Avant Java 17, on avait √ßa :

[source,java]
----
if (facture instanceof FacturePay√©e) {
	lettrageService.lettrer(((FacturePay√©e) facture));
} else if (facture instanceof FactureDue) {
	recouvrementService.relancer(((FactureDue) facture));
}
----

Et √† pr√©sent :

[source,java]
----
if (facture instanceof FacturePay√©e facturePay√©e) {
	lettrageService.lettrer(facturePay√©e);
} else if (facture instanceof FactureDue factureDue) {
	recouvrementService.relancer(factureDue);
}
----

Ici le pattern √† matcher est l‚Äôappartenance aux classes `FacturePay√©e` et `FactureDue`.
On teste si l‚Äôinstance a un des types, et une conversion implicite est faite vers une "binding variable" (`facturePay√©e` ou `factureDue`).

== Comment le Pattern Matching remplace-t-il le visitor pattern ?

J‚Äôai promis des exemples de code, les voici.

Voici l'impl√©mentation du visitor pattern avec le mod√®le de Facture :

[source,java]
----

interface FactureVisitable {
	default void accept(FactureVisitor factureVisitor) {
		factureVisitor.visit(this);
	}
}

abstract class Facture implements FactureVisitable {
}

class FacturePay√©e extends Facture {
}

class FactureDue extends Facture {
}

interface FactureVisitor {
	void visit(FacturePay√©e facturePay√©e);

	void visit(FactureDue factureDue);
}

interface ServiceLettrage {
	void lettrer(FacturePay√©e facturePay√©e);
}

interface ServiceRecouvrement {
	void relancer(FactureDue factureDue);
}

record MainFactureVisitor(ServiceLettrage serviceLettrage, ServiceRecouvrement serviceRecouvrement) implements FactureVisitor {

	@Override
	public void visit(FacturePay√©e facturePay√©e) {
		serviceLettrage.lettrer(facturePay√©e);
	}

	@Override
	public void visit(FactureDue factureDue) {
		serviceRecouvrement.relancer(factureDue);
	}
}

record FactureService(MainFactureVisitor mainFactureVisitor) {

	public void traiterFacture(Facture facture) {
		facture.accept(mainFactureVisitor);
	}
}

----

Et maintenant :

[source,java]
----
record FactureService(MainFactureVisitor mainFactureVisitor) {

	public void traiterFacture(Facture facture) {
		if (facture instanceof FacturePay√©e facturePay√©e) {
			lettrageService.lettrer(facturePay√©e);
		} else if (facture instanceof FactureDue factureDue) {
			recouvrementService.relancer(factureDue);
		}
	}
}
----

== Qu‚Äôest-ce que la "d√©construction"

Ce concept a un objectif similaire au I de SOLID : la s√©gr√©gation.

Si je re√ßois un objet avec 42 champs alors que j‚Äôen ai besoin que de 2, la "_deconstruction on pattern_" va m‚Äôaider.

Regardons √ßa avec du code.

J‚Äôai mon √©norme dto re√ßu :

[source,java]
----
public record Product(
  String type,
  String price,
  String name,
  // imaginez ici 39 autres champs
){}
----

Mais la r√®gle m√©tier que je veux appliquer ne porte que sur le `type` et le `price`.
Je peux alors √©tendre le concept de `instanceof` pr√©c√©dent, en lui ajoutant une d√©construction du Record "Product" :

[source,java]
----
if (object instanceof Product(String type, String price)) {
  myUseCase.execute(type, price);
}
----

Ici, `type` et `price` sont des "binding variables" g√©n√©r√©es implicitement si l‚Äô`object` match le pattern `Product`.

=== Et √ßa sert √† quoi ?

Tout seul comme √ßa, pas encore grand-chose.

//Cela r√©pond √† un besoin fondamental des d√©veloppeurs : faire varier des comportements √† la Runtime. Pour un type on veut le comportement A, et pour un autre on veut le comportement B.

Pour le cas du `instanceof`, on gagne toutefois nettement en intelligibilit√© du code.

Comparez plut√¥t avec la m√©thode habituelle :

[source,java]
----
if (vehicle instanceof Car) {
  ((Car) vehicle).drive();
} else if (vehicle instanceof Plane) {
  ((Plane) vehicle).fly();
}
----

[source,java]
----
if (object instanceof Product) {
  String type = ((Product) object).type;
  String price = ((Product) object).price;
  myUseCase.execute(type, price);
}
----

Mais l√† o√π √ßa prend tout son int√©r√™t, c‚Äôest quand on y ajoute le concept de classe scell√©e dans un "Switch on Pattern".

Voyons cela.

[source,java]
----
public sealed interface Document permits Invoice, Contract {}
public record Invoice(int amount, String buyer, String Seller) implements Document {}
public record Contract(List<String> parties, List<String> formalities, List<String> terms) implements Document {}
----

Ici, gr√¢ce au m√©canisme de sceau (`sealed`), on indique au compilateur la liste exhaustive des impl√©mentations de Document :

* Invoice
* Contract

Les DTO `Invoice` et `Contract` sont re√ßu dans les modules Customer, Administrator et Partner (1 module = 1 context m√©tier).

Pour chaque impl√©mentation, on veut effectuer des validations m√©tiers diff√©rentes.

La m√©thode habituelle de la programmation orient√©e object, c‚Äôest d‚Äôavoir une m√©thode `void validate()` dans l‚Äôinterface Document, et de la faire impl√©menter par Invoice et Contract.

Le probl√®me avec √ßa, c‚Äôest que

Mettons alors qu‚Äôon re√ßoive un DTO Document.

Impl√©mentons la s√©lection de la validation √† appliquer √† l‚Äôaide

[source,java]
----

----

Impl√©mentons la s√©lection de la validation √† appliquer √† l‚Äôaide d‚Äôun "Switch on Pattern" :

[source,java]
----

----

== Qu‚Äôest-ce que √ßa va apporter √† notre code ?

Plus de validation √† la compile-time, et donc :

* Plus de s√©curit√©
* D√©velopper plus intuitivement (le compilateur nous dis ce qu‚Äôon a oubli√©)
* Faire √©merger de meilleurs designs

=== Dans quels langages on en trouve d√©j√†

* https://docs.scala-lang.org/tour/pattern-matching.html[Scala]
* https://doc.rust-lang.org/rust-by-example/flow_control/match.html[Rust]

== Conclusion

== brainstorm area

* Pattern guards, Guarded Pattern
* Sealed classes
* Expressivit√©
* Le pattern matching permet de s√©parer la logique m√©tier des entit√©s sur lesquelles elle agit (Tout comme le pattern Visitor).