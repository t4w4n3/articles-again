= Java 17, plus qu’une LTS, une milestone du record & pattern matching
Antoine Saqlesse - a.salesse@younup.fr
:toc:

== Intro

Promis juré, cet article n’est pas une liste de https://docs.oracle.com/javase/specs/jls/se17/html/index.html[JLS]footnote:[JLS : Java Language Specification] / JSRfootnote:[JSR : Java Specification Request] / JEPfootnote:[JEP : JDK Enhancement Proposal].

Depuis le xxx, les articles Java 17 pleuvent.

Ça y est, on a bien compris que cette version est une LTSfootnote:[LTS : Long Term Support].

Mais c’est aussi bien plus que cela. C’est une milestone de l’objectif ambitieux de pouvoir utiliser le pattern matching dans :

* les `instanceof`
* les `switch`
* des déconstructions de record
* des déconstructions de tableaux
* des `match`
* des structures

C’est donc de ça qu’on parle ici :

* Qu’est-ce que le pattern matching ?
* À quoi ça sert ?
* Qu’est-ce que ça va apporter à notre code ?

Et avec bien sûr des exemples de code !

== Qu’est-ce que le pattern matching ?

Je pense qu'on ne peut pas couper à la définition de Wikipédia :

[quote, https://en.wikipedia.org/wiki/Pattern_matching]
--
In computer science, pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern
--

=== À quoi ça sert ?

=== Dans quels langages on en trouve déjà

* https://docs.scala-lang.org/tour/pattern-matching.html[Scala]

== Faire varier des comportements à la runtime

=== Exemples de variation de comportement

* if this, then do something, else do something else
* switch case
* Spring FactoryBean
* Qualifying beans before request scoped injection
* Strategy pattern
* Programmation fonctionnelle (mettre une Function en argument d'une méthode)

== Qu’est-ce que ça va apporter à notre code ?

Plus de validation à la compile-time, et donc :

* Plus de sécurité
* Développer plus intuitivement (le compilateur nous dis ce qu’on a oublié)
* Faire émerger de meilleurs designs

== Conclusion

// brainstorm area
// * Pattern guards
// * Sealed classes



