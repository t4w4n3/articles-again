= Java 17, le record & pattern matching c‚Äôest pour maintenant ?
Antoine Salesse - a.salesse@younup.fr
:toc: preamble
:caution-caption: ‚ö†
:tabsize: 2
:source-highlighter: rouge
:docinfo: private

Promis jur√©, cet article n‚Äôest pas une liste des "nouvelles fonctionnalit√©s de Java" (https://docs.oracle.com/javase/specs/jls/se17/html/index.html[JLS]footnote:[JLS : Java Language Specification] /
https://stackoverflow.com/a/51286665[JSR]footnote:[JSR : Java Specification Request] / https://stackoverflow.com/a/51286665[JEP]footnote:[JEP : JDK Enhancement Proposal]).

Depuis sa sortie en septembre 2021, les articles sur Java *17* pleuvent.

Ok, √ßa y est, on a bien compris que cette version est une https://stackoverflow.com/a/51286665[LTS]footnote:[LTS : Long Term Support].

Mais c‚Äôest aussi bien plus que cela. +
C‚Äôest une milestone de l‚Äôobjectif ambitieux nomm√© +
*"Record and Array Pattern Matching"*.

Cet objectif est un ensemble de fonctionnalit√©s synergiques :

* Les `instanceof` avec "Type Patterns" (dispo en 16)
* Les Switch on Patterns (Java 17 preview, et probablement dispo en 19)
* La d√©construction de `record` (Peut-√™tre Java 19 preview)
* La d√©construction d‚Äôarray (Java 19+ ?)
* Les imbrications de patterns (pas de visibilit√© de dispo)

C‚Äôest donc de ces features dont on parle ici :

* √Ä quoi elles servent ?
* Comment et dans quels contextes les utiliser ?
* Qu‚Äôapportent-elles √† notre code ?

Et avec bien s√ªr des exemples de code !

== Les applications de gestion aujourd‚Äôhui

Aujourd‚Äôhui le design de nos backend d‚Äôapplications de gestions pousse (üå±) autour d‚Äôune probl√©matique : +
*Faire varier des comportements en fonction de cas d‚Äôusage*

Dans ce genre d‚Äôapplications, quelle que soit l‚Äôarchitecture choisie ou le style dev, on se retrouve √† un moment ou un autre √† :

1.{nbsp}Mod√©liser notre domaine m√©tier ::
Cela peut √™tre fait dans un package sp√©cifique avec des POJO, ou avec des `Entity` JPA. +
La seconde option est la plus r√©pandue, mais ce n‚Äôest pas ma pr√©f√©r√©e.
Je trouve que c‚Äôest une erreur de concevoir le business d‚Äôune application autour d‚Äôune base de donn√©es. +
2.{nbsp}√âcrire des DTO ::
Dans l‚Äôid√©al, un dto est immutable (Il n‚Äôy a aucune raison de changer la repr√©sentation d‚Äôune donn√©e transmise √† un moment T). +
Le Record est la structure de donn√©es la plus appropri√©e. +
Sinon, avant Java 14, on a les `@Value` de Lombok.

Dans nos applications modulaires, on peut avoir envie de partager ces structures de donn√©es entre les modules :

[plantuml,Mod√®le du domain Facture,png]
----
@startuml
allow_mixing

node "Domain model" {
	class Facture
}

node "Module lettrage" {
	usecase usecaseLettragePartiel
	usecaseLettragePartiel - Facture
}

node "Module recouvrement" {
	usecase usecasePremiereRelance
	usecasePremiereRelance - Facture
}

@enduml
----

Et bien pour faire varier les comportements des actions affectant ces classes, la POO nous incite √† ajouter des m√©thodes sur nos classes de domaine. +
//En effet, c‚Äôest un Objet, il a un √©tat, et il peut porter des m√©thodes consommant ou modifiant cet √©tat.

Par exemple, pour la domain-class `Facture`, le module lettrage pourrait vouloir ajouter une m√©thode `calculerMontantRestantAPayer()`. +
Le module envoie pourrait vouloir une m√©thode `getDestinataires()`.

[plantuml,Mod√®le de domaine avec Facture et cas d‚Äôutilisation,png]
----
@startuml
allow_mixing

node "Domain model" {


	class Facture implements MontantCalculable, Envoyable {
	Integer calculerMontantRestantAPayer()
	List<Personne> getDestinataires()
  }

  interface MontantCalculable
  interface Envoyable
}

node "Module lettrage" {
  usecase usecaseLettragePartiel
  usecaseLettragePartiel - Facture
}

node "Module envoi" {
  usecase usecasePremiereRelance
  usecasePremiereRelance - Facture
}

@enduml
----

[source,java]
----
class Facture implements MontantCalculable, Envoyable {
	private String libelle;
	private CodeFacture code;
	private Client client;
	private Re√ßu re√ßu;
	private Devise montant;

	@Override
	public Integer calculerMontantRestantAPayer(){
		...
	}

	@Override
	public List<Personne> getDestinataires(){
		...
	}

	...
}
----

Au bout d‚Äôun moment, notre domain-class `Facture` a beaucoup de m√©thodes issues de diff√©rents modules. +
Le module lettrage utilise `Facture` et se retrouve √† pouvoir appeler les m√©thodes du module d‚Äôenvoi‚ÄØ; ce qui viole au moins :

* Le https://fr.wikipedia.org/wiki/Principe_de_s%C3%A9gr%C3%A9gation_des_interfaces[principe de s√©gr√©gation des interfaces]
* Le https://fr.wikipedia.org/wiki/Principe_de_responsabilit%C3%A9_unique  [principe de responsabilit√© unique] (Car La class Document a maintenant 2 raisons de changer : le contexte _lettrage_ et le contexte _envoi_)

Effet bonus : Quand on change `Facture` dans le cadre du contexte _lettrage_, on doit recompiler/relivrer aussi le contexte _envoi_.

=== Solution : s√©parer la logique m√©tier des structures sur lesquelles elle agit

Pour y parvenir, on utilisait jusque-l√† 3 patterns :

* Le https://en.wikipedia.org/wiki/Visitor_pattern#Sources_3[visitor pattern]footnote:["Today, to express ad-hoc polymorphic calculations like this we would use the cumbersome visitor pattern". source : https://openjdk.java.net/jeps/405]
* Le https://en.wikipedia.org/wiki/Delegation_pattern[delegate pattern]
* Le pattern service-everywhere avec des m√©thodes √† 8 arguments (un anti-pattern d‚Äôapr√®s moi), qui nait de la programmation proc√©durale

Mais √† pr√©sent avec Java 17, une quatri√®me solution √©l√©gante s‚Äôoffre √† nous : Le Pattern Matching.

== Mais qu‚Äôest-ce que le pattern matching ?

Je pense qu‚Äôon ne peut pas couper √† la d√©finition de Wikip√©dia :

[quote,https://en.wikipedia.org/wiki/Pattern_matching]
--
In computer science, pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern.
--

On a tendance √† penser alors aux expressions r√©guli√®res, mais non, il ne s‚Äôagit pas de cela.

L√†, les patterns √† matcher sont des structures de donn√©es :

* Des classes
* Des interfaces
* Des array
* Et bien s√ªr des records !

Je trouve que le cas du matching sur `instanceof` avec Type-Pattern est le plus facile √† comprendre. +
Avant Java 17, on avait √ßa :

[source,java]
----
if (facture instanceof FacturePay√©e) { // Oui je mets des accents dans mon code fran√ßais. La s√©mantique !
	lettrageService.lettrer(((FacturePay√©e) facture));
	return;
}
if (facture instanceof FactureDue) {
	recouvrementService.relancer(((FactureDue) facture));
}
----

Et √† pr√©sent :

[source,java]
----
if (facture instanceof FacturePay√©e facturePay√©e) {
	lettrageService.lettrer(facturePay√©e);
	return;
}
if (facture instanceof FactureDue factureDue) {
	recouvrementService.relancer(factureDue);
}
----

Ici le pattern √† matcher est l‚Äôappartenance aux classes `FacturePay√©e` et `FactureDue`.
On teste si l‚Äôinstance a un des types, et un cast implicite est fait vers une "binding variable" (`facturePay√©e` ou `factureDue`).

== Comment le Pattern Matching remplace-t-il le visitor pattern ?

J‚Äôai promis des exemples de code, les voici.

Voici l‚Äôimpl√©mentation du visitor pattern avec le mod√®le de Facture :

[source,java]
----

interface FactureVisitable {
	default void accept(FactureVisitor factureVisitor) {
		factureVisitor.visit(this);
	}
}

abstract class Facture implements FactureVisitable {
}

class FacturePay√©e extends Facture {
}

class FactureDue extends Facture {
	private Integer nombreRelance = 0;

	public void incrementerNombreRelance(){
		nombreRelance++;
	}

	public boolean aDejaEteRelanc√©e() {
		return nombreRelance >= 1;
	}
}

interface FactureVisitor {
	void visit(FacturePay√©e facturePay√©e);

	void visit(FactureDue factureDue);
}

interface ServiceLettrage {
	void lettrer(FacturePay√©e facturePay√©e);
}

interface ServiceRecouvrement {
	void relancer(FactureDue factureDue);
}

record MainFactureVisitor(ServiceLettrage serviceLettrage, ServiceRecouvrement serviceRecouvrement) implements FactureVisitor {

	@Override
	public void visit(FacturePay√©e facturePay√©e) {
		serviceLettrage.lettrer(facturePay√©e);
	}

	@Override
	public void visit(FactureDue factureDue) {
		serviceRecouvrement.relancer(factureDue);
	}
}

record FactureService(MainFactureVisitor mainFactureVisitor) implements TraitementFacture {

	public void traiterFacture(Facture facture) {
		facture.accept(mainFactureVisitor);
	}
}

----

On observe que le rapport code utile/pure invention n‚Äôest pas excellent.

Et maintenant :

[source,java]
----
record FactureService(LettrageService lettrageService, RecouvrementService recouvrementService) implements TraitementFacture {

	public void traiterFacture(Facture facture) {
		if (facture instanceof FacturePay√©e facturePay√©e) {
			lettrageService.lettrer(facturePay√©e);
			return;
		}
		if (facture instanceof FactureDue factureDue) {
			recouvrementService.relancer(factureDue);
		}
	}
}
----

Le FactureService se suffit √† lui-m√™me, et la lisibilit√© me semble tr√®s acceptable.

Mais avez-vous remarqu√© quelque chose dans ce dernier bout de code ?

Le cas o√π `facture` est d‚Äôun autre type n‚Äôest pas g√©r√© ! +
Et non, pas de `throw new NotImplementedException()` cette fois-ci. +

C‚Äôest l√† que la fonctionnalit√© Java 15 de types scell√©s intervient. +
Modifions un peu notre mod√®le :

[source,java]
----
abstract sealed class Facture permits FacturePay√©e, FactureDue {
}

final class FacturePay√©e extends Facture {
}

final class FactureDue extends Facture {
	private Integer nombreRelance = 0;

	public void incrementerNombreRelance(){
		nombreRelance++;
	}

	public boolean aDejaEteRelanc√©e() {
		return nombreRelance >= 1;
	}
}
----

Traduction en fran√ßais : ::
Il n‚Äôexiste que 2 types de Facture possibles : FacturePay√©e et FactureDue. +
Ces derni√®res ne peuvent √™tre √©tendues. +
Point.

Cela donne donc :

[source,java]
----
record FactureService(LettrageService lettrageService, RecouvrementService recouvrementService) implements TraitementFacture {

	public void traiterFacture(Facture facture) {
		switch (facture) {
			case FacturePay√©e facturePay√©e -> lettrageService.lettrer(facturePay√©e);
			// case FactureDue factureDue -> recouvrementService.relancer(factureDue);
		}
	}
}
----

J‚Äôai comment√© le cas de la `FactureDue` afin d‚Äôobserver ce que nous disent le compilateur et l‚Äôide :

image::java_the_switch_statement_does_not_cover_all_possible_input_values.png[alt="java: the switch statement does not cover all possible input values IntelliJ"]

image::java_compile_error_java_17_the_switch_statement_does_not_cover_all_possible_input_values.png[alt="java compile error java 17 the switch statement does not cover all possible input values"]

On doit alors d√©clarer le `Consumer<? extends Facture>` de tous les cas restants, ou bien les grouper dans un `default` :

[source%linenums,java,highlight=6..7]
----
record FactureService(LettrageService lettrageService, RecouvrementService recouvrementService) implements TraitementFacture {

	public void traiterFacture(Facture facture) {
		switch (facture) {
			case FacturePay√©e facturePay√©e -> lettrageService.lettrer(facturePay√©e);
			// case FactureDue factureDue -> recouvrementService.relancer(factureDue);
			default -> LOGGER.info("Cool y a rien √† faire pour le cas l√† !");
		}
	}
}
----

Avec cette syntaxe, le langage nous apporte une validation m√©tier de plus √† la compile time (soit plus t√¥t qu‚Äô√† la runtime ou encore √† la _prodtime_). +
C‚Äôest les TDDistes qui sont contents.

Et si on allait encore plus loin ? +
Allez, ajoutons une feature preview de Java 17 : un "Guarded Pattern"

[source%linenums,java,highlight=9..9]
----
record FactureService(
		LettrageService lettrageService,
		RecouvrementService recouvrementService)
		implements TraitementFacture {

	public void traiterFacture(Facture facture) {
		switch (facture) {
			case FacturePay√©e facturePay√©e -> lettrageService.lettrer(facturePay√©e);
			case FactureDue factureDue && factureDue.aD√©j√†√ât√©Relanc√©e() -> recouvrementService.demarrerRecouvrement(factureDue);
			case FactureDue factureDue -> recouvrementService.relancer(factureDue);
		}
	}
}
----

Alors c'est tr√®s bien tout √ßa, mais l‚Äôobjectif √† terme du pattern matching va encore plus loin en ce qui concerne les records. +

Reprenons notre exemple de `Facture`, mais consid√©rons qu'elle vient d'arriver d'un `Controlleur` sour forme de DTO (et donc de record) :

[source,java]
----
record Facture(String code, String libell√©, Integer montant, ZonedDateTime dateCr√©ation, ...){}
----

Je ne lui donne que quelques champs, mais consid√©rons en plus qu'il y a en une vingtaine, une centaine, beaucoup...

Quand je veux mapper cette facture vers un usecase, alors ce dernier n'a tr√®s certainement besoin que de seulement quelques-uns de ces champs. Le code suivant serait donc une erreur de design :

[source%linenums,java,highlight=8..8]
----
@RestController
class FactureControlleur {

	@PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Long create(@RequestBody Facture facture) {
        Preconditions.checkNotNull(facture);
        notifierNouvelleFactureUseCase.handle(facture);
		return factureService.handle(facture)
    }
}
----

On va pouvoir (Java >= 19) les d√©construire.

/!\ On passe maintenant sur du code qu

// todo : introduire un exemple qui justifie de d√©crire la d3construction

== Qu‚Äôest-ce que la "d√©construction"

Ce concept a un objectif similaire au I de SOLID : la s√©gr√©gation.

Si je re√ßois un objet avec 42 champs alors que j‚Äôen ai besoin que de 2, la "_deconstruction on pattern_" va m‚Äôaider.

Regardons √ßa avec du code.

J‚Äôai mon √©norme dto re√ßu :

[source,java]
----
public record Product(
  String type,
  String price,
  String name,
  // imaginez ici 39 autres champs
){}
----

Mais la r√®gle m√©tier que je veux appliquer ne porte que sur le `type` et le `price`.
Je peux alors √©tendre le concept de `instanceof` pr√©c√©dent, en lui ajoutant une d√©construction du Record "Product" :

[source,java]
----
if (object instanceof Product(String type, String price)) {
  myUseCase.execute(type, price);
}
----

Ici, `type` et `price` sont des "binding variables" g√©n√©r√©es implicitement si l‚Äô`object` match le pattern `Product`.

=== Et √ßa sert √† quoi ?

Tout seul comme √ßa, pas encore grand-chose.

//Cela r√©pond √† un besoin fondamental des d√©veloppeurs : faire varier des comportements √† la Runtime. Pour un type on veut le comportement A, et pour un autre on veut le comportement B.

Pour le cas du `instanceof`, on gagne toutefois nettement en intelligibilit√© du code.

Comparez plut√¥t avec la m√©thode habituelle :

[source,java]
----
if (vehicle instanceof Car) {
  ((Car) vehicle).drive();
} else if (vehicle instanceof Plane) {
  ((Plane) vehicle).fly();
}
----

[source,java]
----
if (object instanceof Product) {
  String type = ((Product) object).type;
  String price = ((Product) object).price;
  myUseCase.execute(type, price);
}
----

Mais l√† o√π √ßa prend tout son int√©r√™t, c‚Äôest quand on y ajoute le concept de classe scell√©e dans un "Switch on Pattern".

Voyons cela.

[source,java]
----
public sealed interface Document permits Invoice, Contract {}
public record Invoice(int amount, String buyer, String Seller) implements Document {}
public record Contract(List<String> parties, List<String> formalities, List<String> terms) implements Document {}
----

Ici, gr√¢ce au m√©canisme de sceau (`sealed`), on indique au compilateur la liste exhaustive des impl√©mentations de Document :

* Invoice
* Contract

Les DTO `Invoice` et `Contract` sont re√ßu dans les modules Customer, Administrator et Partner (1 module = 1 context m√©tier).

Pour chaque impl√©mentation, on veut effectuer des validations m√©tiers diff√©rentes.

La m√©thode habituelle de la programmation orient√©e object, c‚Äôest d‚Äôavoir une m√©thode `void validate()` dans l‚Äôinterface Document, et de la faire impl√©menter par Invoice et Contract.

Le probl√®me avec √ßa, c‚Äôest que

Mettons alors qu‚Äôon re√ßoive un DTO Document.

Impl√©mentons la s√©lection de la validation √† appliquer √† l‚Äôaide

[source,java]
----

----

Impl√©mentons la s√©lection de la validation √† appliquer √† l‚Äôaide d‚Äôun "Switch on Pattern" :

[source,java]
----

----

== Qu‚Äôest-ce que √ßa va apporter √† notre code ?

Plus de validation √† la compile-time, et donc :

* Plus de s√©curit√©
* D√©velopper plus intuitivement (le compilateur nous dis ce qu‚Äôon a oubli√©)
* Faire √©merger de meilleurs designs

=== Dans quels langages on en trouve d√©j√†

* https://docs.scala-lang.org/tour/pattern-matching.html[Scala]
* https://doc.rust-lang.org/rust-by-example/flow_control/match.html[Rust]

== Conclusion

== brainstorm area

* Pattern guards, Guarded Pattern
* Sealed classes
* Expressivit√©
