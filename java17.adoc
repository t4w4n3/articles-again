= Java 17, le record & pattern matching c‚Äôest pour maintenant ?
Antoine Salesse - a.salesse@younup.fr
:toc:
:caution-caption: ‚ö†

== Intro

Promis jur√©, cet article n‚Äôest pas une liste des "nouvelles fonctionnalit√©s de Java" (https://docs.oracle.com/javase/specs/jls/se17/html/index.html[JLS]footnote:[JLS : Java Language Specification] /
https://stackoverflow.com/a/51286665[JSR]footnote:[JSR : Java Specification Request] / https://stackoverflow.com/a/51286665[JEP]footnote:[JEP : JDK Enhancement Proposal] ).

Depuis sa sortie en septembre 2021, les articles sur Java *17* pleuvent.

Ok, √ßa y est, on a bien compris que cette version est une https://stackoverflow.com/a/51286665[LTS]footnote:[LTS : Long Term Support].

Mais c‚Äôest aussi bien plus que cela. +
C‚Äôest une milestone de l‚Äôobjectif ambitieux nomm√© +
*"Record and Array Pattern Matching"*.

Cet objectif est un ensemble de fonctionnalit√©s synergiques :

* Les `instanceof` avec "Type Patterns" (dispo en 16)
* Les Switch on Patterns (dispo en 17 preview)
* La d√©construction d‚Äôarray (Peut-√™tre dispo en 19 preview)
* La d√©construction de `record` (Peut-√™tre dispo en 19 preview)
* Les imbrications de patterns (pas de visibilit√© de dispo)

C‚Äôest donc de ces features dont on parle ici :

* √Ä quoi elles servent ?
* Comment et dans quels contextes les utiliser ?
* Qu'apportent-elles √† notre code ?

Et avec bien s√ªr des exemples de code !

== Les applications de gestion aujourd‚Äôhui

Aujourd‚Äôhui le design de nos backend d‚Äôapplications de gestions pousse (üå±) autour d‚Äôune probl√©matique : +
*Faire varier des comportements en fonction de cas d‚Äôusage*

Dans une application modulaire id√©ale, un module repr√©sente un contexte m√©tier (https://martinfowler.com/bliki/BoundedContext.html[Bounded Context]).

Illustrons cela avec 3 contextes :

* Customer
* Administrator
* Partner

Tous les 3 manipulent le concept de `Document`. +
On retrouve alors au moins 2 designs de partage de ce concept :

1.{nbsp}L‚Äôarchitecture hexagonale modulaire::
Elle peut prendre la forme d‚Äôun monolith modulaire, ou bien de microservices. +
Chacun des modules/services poss√®de un package `domain` o√π on mod√©lise le domaine m√©tier, dont `Document`. +
Ils utilisent des mappers pour s‚Äô√©changer le concept de `Document` √† travers de https://en.wikipedia.org/wiki/Data_transfer_object[DTO]s, envoy√©s en http (microservices) ou en runtime (monolith modulaire). +
Grace au d√©couplage des contextes m√©tiers, les m√©thodes des classes `Document` ne peuvent pas √™tre appel√©es depuis les autres modules. +
On peut alors se permettre de laisser `Document` responsable de la logique m√©tier le concernant.
// mettre un sch√©ma ici

2.{nbsp}L‚Äôarchitecture monolithique::
Ici les contextes m√©tiers n‚Äôont pas √©t√© d√©couverts et il n‚Äôy a alors pas de fronti√®re d√©couplante entre eux. +
C‚Äôest acceptable pour une application raisonnablement complexe, dans laquelle il n‚Äôy a d'ailleurs peut-√™tre m√™me qu‚Äôun seul context m√©tier. +
//Un monolith modulaire sans d√©couplage entre les modules n'est alors pas modulaire par essence.
On a toujours une classe `Document` dans un package `domain`.

Dans le premier design, tout va bien, continuons √† continuer ainsi ...

[CAUTION]
Mais dans le deuxi√®me, attention !

Si on met dans `Document` la logique m√©tier agissant dessus, alors on couple fortement la totalit√© de l'application avec l'impl√©mentation de `Document` !
Cela impacte fortement la parall√©lisation, le scope (et donc la vitesse) de recompilation de l'application.

On veut alors *s√©parer la logique m√©tier des entit√©s sur lesquelles elle agit*.

Pour y parvenir, on utilisait jusque-l√† 2 pattern :

* le https://en.wikipedia.org/wiki/Visitor_pattern#Sources_3[visitor pattern]footnote:["Today, to express ad-hoc polymorphic calculations like this we would use the cumbersome visitor pattern". source : https://openjdk.java.net/jeps/405]
* le everything-is-a-service avec des m√©thodes √† 8 arguments (un anti-pattern d'apr√®s moi)

Mais √† pr√©sent avec java 17, une troisi√®me solution √©l√©gante s'offre √† nous : Le Pattern Matching.

== Qu‚Äôest-ce que le pattern matching ?

Je pense qu‚Äôon ne peut pas couper √† la d√©finition de Wikip√©dia :

[quote,https://en.wikipedia.org/wiki/Pattern_matching]
--
In computer science, pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern.
--

On a tendance √† penser alors aux expressions r√©guli√®res, mais non, il ne s‚Äôagit pas de cela.

L√†, les patterns √† matcher sont des structures de donn√©es :

* Des classes
* Des interfaces
* Des array
* Et bien s√ªr des records !

Je trouve que le cas du matching sur `instanceof` avec Type-Pattern est le plus facile √† comprendre :

[source,java]
----
if (vehicle instanceof Car car) {
  car.drive();
} else if (vehicle instanceof Plane plane) {
  plane.fly();
}
----

Ici le pattern √† matcher est l‚Äôappartenance aux classes `Car` et `Plane`.
On teste si l‚Äôinstance a un des types, et une conversion implicite est faite vers une "binding variable" (`car` ou `plane`).

== Comment le Pattern Matching remplace-t-il le visitor pattern ?

//Des exemples furent promis, des exemples sont alors donn√©s.
Exemples j'ai promis, exemples je donne.



== Qu‚Äôest-ce que la "d√©construction"

Ce concept a un objectif similaire au I de SOLID : la s√©gr√©gation.

Si je re√ßois un objet avec 42 champs alors que j‚Äôen ai besoin que de 2, la "_deconstruction on pattern_" va m‚Äôaider.

Regardons √ßa avec du code.

J‚Äôai mon √©norme dto re√ßu :

[source,java]
----
public record Product(
  String type,
  String price,
  String name,
  // imaginez ici 39 autres champs
){}
----

Mais la r√®gle m√©tier que je veux appliquer ne porte que sur le `type` et le `price`.
Je peux alors √©tendre le concept de instanceof pr√©c√©dent, en lui ajoutant une d√©construction du Record "Product" :

[source,java]
----
if (object instanceof Product(String type, String price)) {
  myUseCase.execute(type, price);
}
----

Ici, `type` et `price` sont des "binding variables" g√©n√©r√©es implicitement si l‚Äô`object` match le pattern `Product`.

=== Et √ßa sert √† quoi ?

Tout seul comme √ßa, pas encore grand-chose.

//Cela r√©pond √† un besoin fondamental des d√©veloppeurs : faire varier des comportements √† la Runtime. Pour un type on veut le comportement A, et pour un autre on veut le comportement B.

Pour le cas du `instanceof`, on gagne toutefois nettement en intelligibilit√© du code.

Comparez plut√¥t avec la m√©thode habituelle :

[source,java]
----
if (vehicle instanceof Car) {
  ((Car) vehicle).drive();
} else if (vehicle instanceof Plane) {
  ((Plane) vehicle).fly();
}
----

[source,java]
----
if (object instanceof Product) {
  String type = ((Product) object).type;
  String price = ((Product) object).price;
  myUseCase.execute(type, price);
}
----

Mais l√† o√π √ßa prend tout son int√©r√™t, c‚Äôest quand on y ajoute le concept de classe scell√©e dans un "Switch on Pattern".

Voyons cela.

[source,java]
----
public sealed interface Document permits Invoice, Contract {}
public record Invoice(int amount, String buyer, String Seller) implements Document {}
public record Contract(List<String> parties, List<String> formalities, List<String> terms) implements Document {}
----

Ici, gr√¢ce au m√©canisme de sceau (`sealed`), on indique au compilateur la liste exhaustive des impl√©mentations de Document :

* Invoice
* Contract

Les DTO `Invoice` et `Contract` sont re√ßu dans les modules Customer, Administrator et Partner (1 module = 1 context m√©tier).

Pour chaque impl√©mentation, on veut effectuer des validations m√©tiers diff√©rentes.

La m√©thode habituelle de la programmation orient√©e object, c‚Äôest d‚Äôavoir une m√©thode `void validate()` dans l‚Äôinterface Document, et de la faire impl√©menter par Invoice et Contract.

Le probl√®me avec √ßa, c‚Äôest que

Mettons alors qu‚Äôon re√ßoive un DTO Document.

Impl√©mentons la s√©lection de la validation √† appliquer √† l‚Äôaide

[source,java]
----

----

Impl√©mentons la s√©lection de la validation √† appliquer √† l‚Äôaide d‚Äôun "Switch " on Pattern :

[source,java]
----

----

== Qu‚Äôest-ce que √ßa va apporter √† notre code ?

Plus de validation √† la compile-time, et donc :

* Plus de s√©curit√©
* D√©velopper plus intuitivement (le compilateur nous dis ce qu‚Äôon a oubli√©)
* Faire √©merger de meilleurs designs

=== Dans quels langages on en trouve d√©j√†

* https://docs.scala-lang.org/tour/pattern-matching.html[Scala]
* https://doc.rust-lang.org/rust-by-example/flow_control/match.html[Rust]

== Conclusion

== brainstorm area

* Pattern guards, Guarded Pattern
* Sealed classes
* Expressivit√©
* le pattern matching permet de s√©parer la logique m√©tier des entit√©s sur lesquelles elle agit (Tout comme le pattern Visitor).